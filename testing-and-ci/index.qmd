---
author: Patrick J. Roddy
date: 2025-12-03
format: revealjs
subtitle: "[CCMI CDT: Software Engineering Fundamentals](https://ccmi-cdt.org)"
title: Testing and CI
---

{{< include /_includes/qr-code.qmd >}}

# Testing

<!-- vale RedHat.TermsWarnings = NO -->

## Unit Tests {data-menu-title="Unit Tests (i)"}

<!-- vale RedHat.TermsWarnings = YES -->

- Low level
- Close to the source of the application
- Tests individual methods/functions
- Cheap to automate
- Run quickly

## Example {data-menu-title="Unit Tests (ii)"}

```{.python}
def add(a, b):
    return a + b

def test_add_positive_numbers():
    assert add(2, 3) == 5

def test_add_negative_numbers():
    assert add(-1, -1) == -2
```

## Example {data-menu-title="Unit Tests (iii)"}

```{.python}
import pytest

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

def test_divide_by_zero_raises_error():
    with pytest.raises(ValueError, match="Cannot divide by zero"):
        divide(10, 0)

@pytest.mark.parametrize(
    "a,b,expected",
    [
        (10, 2, 5),
        (20, 4, 5),
        (100, 10, 10),
    ],
)
def test_divide_various_inputs(a, b, expected):
    assert divide(a, b) == expected
```

<!-- vale RedHat.TermsWarnings = NO -->

## Integration Tests {data-menu-title="Integration Tests (i)"}

<!-- vale RedHat.TermsWarnings = YES -->

- Verifies that different part of the application work well together
- e.g. test interaction with database/make sure microservices work together
- More expensive to run
- Many parts of the application need to be up and running

## Integration Tests {data-menu-title="Integration Tests (ii)"}

```{.python}
import pytest
from sqlalchemy import create_engine
from myapp.repository import UserRepository

@pytest.fixture
def db_engine():
    """Create in-memory database for testing"""
    engine = create_engine("sqlite:///:memory:")
    yield engine
    engine.dispose()

@pytest.fixture
def user_repo(db_engine):
    """Create repository with test database"""
    repo = UserRepository(db_engine)
    repo.create_tables()
    return repo
```

## Integration Tests {data-menu-title="Integration Tests (iii)"}

```{.python}
from myapp.models import User

def test_create_and_retrieve_user(user_repo):
    # Test that we can save to database and retrieve
    user = User(name="Alice", email="alice@example.com")
    user_id = user_repo.save(user)

    retrieved_user = user_repo.get_by_id(user_id)
    assert retrieved_user.name == "Alice"
    assert retrieved_user.email == "alice@example.com"

def test_update_user_email(user_repo):
    user = User(name="Bob", email="bob@example.com")
    user_id = user_repo.save(user)

    user_repo.update_email(user_id, "newemail@example.com")
    updated_user = user_repo.get_by_id(user_id)

    assert updated_user.email == "newemail@example.com"
```

<!-- vale RedHat.TermsWarnings = NO -->

## Functional Tests {data-menu-title="Functional Tests (i)"}

<!-- vale RedHat.TermsWarnings = YES -->

- Focus on business requirements of application
- Only verify the output of an action
- In comparison to an integration test it would be a specific value from the
  database rather than just the connection

## Functional Tests {data-menu-title="Functional Tests (ii)"}

```{.python}
import pytest
from myapp.services import OrderService
from myapp.models import Order, Product

@pytest.fixture
def order_service():
    return OrderService()

def test_order_total_calculation(order_service):
    # Test business requirement: order total is correctly calculated
    order = Order()
    order.add_item(Product(name="Widget", price=10.00), quantity=2)
    order.add_item(Product(name="Gadget", price=15.50), quantity=1)

    total = order_service.calculate_total(order)

    # Verify specific business outcome
    assert total == 35.50
```

## Functional Tests {data-menu-title="Functional Tests (iii)"}

```{.python}
import pytest
from myapp.models import Order, Product

def test_discount_applied_for_orders_over_50(order_service):
    order = Order()
    order.add_item(Product(name="Widget", price=60.00), quantity=1)

    total = order_service.calculate_total(order)

    # Business rule: 10% discount for orders over $50
    assert total == 54.00

def test_out_of_stock_items_cannot_be_ordered(order_service):
    order = Order()
    product = Product(name="Rare Item", price=100.00, stock=0)

    with pytest.raises(ValueError, match="out of stock"):
        order_service.process_order(order.add_item(product, quantity=1))
```

<!-- vale RedHat.TermsWarnings = NO -->

## End-to-End Tests {data-menu-title="End-to-End Tests (i)"}

<!-- vale RedHat.TermsWarnings = YES -->

- Replicates user behaviour in a complete application environment
- Verifies that user flows work as expected
- Can be as simple loading a web page
- Expensive to perform
- Hard to support when automated
- Only need a few

## End-to-End Tests {data-menu-title="End-to-End Tests (ii)"}

```{.python}
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By

@pytest.fixture
def browser():
    driver = webdriver.Chrome()
    driver.get("http://localhost:8000")
    yield driver
    driver.quit()

def test_user_can_view_order_history(browser):
    # Login
    browser.find_element(By.ID, "login-link").click()
    browser.find_element(By.ID, "username").send_keys("testuser")
    browser.find_element(By.ID, "password").send_keys("password123")
    browser.find_element(By.ID, "login-btn").click()

    # Navigate to order history
    browser.find_element(By.ID, "account-menu").click()
    browser.find_element(By.ID, "order-history-link").click()

    # Verify orders are displayed
    orders = browser.find_elements(By.CLASS_NAME, "order-item")
    assert len(orders) > 0
```

## End-to-End Tests {data-menu-title="End-to-End Tests (iii)"}

```{.python}
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

def test_complete_purchase_flow(browser):
    # Simulate complete user journey

    # User browses products
    browser.find_element(By.ID, "products-link").click()

    # User adds item to cart
    browser.find_element(By.CLASS_NAME, "add-to-cart-btn").click()

    # User goes to checkout
    browser.find_element(By.ID, "cart-icon").click()
    browser.find_element(By.ID, "checkout-btn").click()

    # User fills in shipping info
    browser.find_element(By.ID, "name").send_keys("John Doe")
    browser.find_element(By.ID, "address").send_keys("123 Main St")
    browser.find_element(By.ID, "submit-order").click()

    # Verify order confirmation appears
    confirmation = WebDriverWait(browser, 10).until(
        EC.presence_of_element_located((By.ID, "order-confirmation"))
    )
    assert "Order placed successfully" in confirmation.text
```

<!-- vale RedHat.TermsWarnings = NO -->

## Acceptance Testing {data-menu-title="Acceptance Tests (i)"}

<!-- vale RedHat.TermsWarnings = YES -->

- Formal tests that verify if a system satisfies business requirements
- Require entire application to be running while testing
- Replicate user behaviours
- Can also measure the performance, reject if certain goals not met

## Acceptance Testing {data-menu-title="Acceptance Tests (ii)"}

<!-- vale RedHat.TermsWarnings = NO -->

## Performance Testing {data-menu-title="Performance Tests (i)"}

<!-- vale RedHat.TermsWarnings = YES -->

- Evaluate how a system performs under a particular workload
- Help measure reliability, speed, scalability, responsiveness
- e.g. observe response times when executing a high number of requests
- Determines if an application meets performance requirements

## Performance Testing {data-menu-title="Performance Tests (ii)"}

<!-- vale RedHat.TermsWarnings = NO -->

## Smoke Testing {data-menu-title="Smoke Tests (i)"}

<!-- vale RedHat.TermsWarnings = YES -->

- Basic tests that check the basic functionality of an application
- Meant to be quick to run
- Goal to give the assurance that major features are working as expected
- Useful after a new build to decide whether to run more expensive tests
- Or after a deployment to make sure application is running in the new environment

## Smoke Testing {data-menu-title="Smoke Tests (ii)"}

## Miscellaneous

- Mutation Testing
- Mocking
